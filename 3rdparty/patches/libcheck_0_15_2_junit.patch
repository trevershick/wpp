diff --git a/CMakeLists.txt b/CMakeLists.txt
index 71893e7..9d3ac07 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -439,8 +439,8 @@ if(NOT THIS_IS_SUBPROJECT)
   set(prefix_save "${PREFIX}")
   set(prefix "${CMAKE_INSTALL_PREFIX}")
   set(exec_prefix "\${prefix}")
-  set(libdir "\${exec_prefix}/lib")
-  set(includedir "\${prefix}/include")
+  set(libdir ${CMAKE_INSTALL_FULL_LIBDIR})
+  set(includedir ${CMAKE_INSTALL_FULL_INCLUDEDIR})
   set(VERSION "${PROJECT_VERSION}")
 
   if (HAVE_SUBUNIT)
@@ -489,6 +489,7 @@ endif()
 
 ###############################################################################
 # Subdirectories
+add_subdirectory(doc)
 add_subdirectory(lib)
 add_subdirectory(src)
 add_subdirectory(checkmk)
diff --git a/configure.ac b/configure.ac
index 1727a3c..9c57a9c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -33,6 +33,11 @@ AC_SUBST(CHECK_MINOR_VERSION)
 AC_SUBST(CHECK_MICRO_VERSION)
 AC_SUBST(CHECK_VERSION)
 
+# The PROJECT_VERSION variable definition is required for
+# compatibility with the CMake configuration interface.
+#
+AC_SUBST([PROJECT_VERSION], $CHECK_VERSION)
+
 # Configure options.
 # allow `./configure --enable-silent-rules' and `make V=0'
 m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([no])])
@@ -386,15 +391,22 @@ AS_IF([test "x$AWK_PATH" = 'x*NO AWK*'],
 # Output files
 AC_CONFIG_HEADERS([config.h])
 
-AC_CONFIG_FILES([check.pc
-                 Makefile
-                 checkmk/Makefile
-		 doc/Makefile
-		 lib/Makefile
-                 src/check.h
-                 src/Makefile
-                 tests/Makefile
-		 tests/test_vars])
+AC_CONFIG_FILES([
+    check.pc
+    Makefile
+    checkmk/Makefile
+    doc/Makefile
+    doc/man/Makefile
+    doc/man/man3/Makefile
+    doc/man/man3/suite_create.3
+    doc/man/man7/Makefile
+    doc/man/man7/libcheck.7
+    lib/Makefile
+    src/check.h
+    src/Makefile
+    tests/Makefile
+    tests/test_vars
+])
 
 AC_OUTPUT
 
diff --git a/doc/CMakeLists.txt b/doc/CMakeLists.txt
new file mode 100644
index 0000000..bb988c1
--- /dev/null
+++ b/doc/CMakeLists.txt
@@ -0,0 +1,23 @@
+#
+# Check: a unit test framework for C
+# Copyright (C) 2020 Jose Fernando Lopez Fernandez
+# 
+# This library is free software; you can redistribute
+# it and/or modify it under the terms of the GNU Lesser
+# General Public License as published by the Free Software
+# Foundation; either version 2.1 of the License, or (at
+# your option) any later version.
+# 
+# This library is distributed in the hope that it will
+# be useful, but WITHOUT ANY WARRANTY; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.  See the GNU Lesser General Public
+# License for more details.
+# 
+# You should have received a copy of the GNU Lesser General
+# Public License along with this library; if not, write
+# to the Free Software Foundation, Inc., 51 Franklin St,
+# Fifth Floor, Boston, MA  02110-1301  USA
+#
+
+ADD_SUBDIRECTORY(man)
diff --git a/doc/Makefile.am b/doc/Makefile.am
index 250cb23..953acaa 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,5 +1,7 @@
 ## Process this file with automake to produce Makefile.in
 
+SUBDIRS = man
+
 info_TEXINFOS = check.texi
 check_TEXINFOS = fdl.texi
 
diff --git a/doc/check.texi b/doc/check.texi
index f6852bc..bf91de6 100644
--- a/doc/check.texi
+++ b/doc/check.texi
@@ -1930,6 +1930,8 @@ of to a file.
 @findex srunner_set_xml
 @findex srunner_has_xml
 @findex srunner_xml_fname
+@findex srunner_xml_format
+@findex srunner_set_xml_format
 The log can also be written in XML.  The following functions define
 the interface for XML logs:
 @example
@@ -1937,6 +1939,8 @@ the interface for XML logs:
 void srunner_set_xml (SRunner *sr, const char *fname);
 int srunner_has_xml (SRunner *sr);
 const char *srunner_xml_fname (SRunner *sr);
+enum xml_format srunner_xml_format(SRunner * sr);
+void srunner_set_xml_format(SRunner * sr, enum xml_format format);
 @end verbatim
 @end example
 
@@ -2048,6 +2052,59 @@ If both plain text and XML log files are specified, by any of above methods,
 then check will log to both files. In other words logging in plain text and XML
 format simultaneously is supported.
 
+JUnit Support is also available.  It is enabled  by a call to 
+@code{srunner_set_xml_format(CK_XML_FORMAT_JUNIT)} before the tests are run. 
+It can also be enabled by environment variable as well.  It is enabled by setting the
+@code{CK_XML_FORMAT_NAME} environment variable to @code{junit}.
+
+Here is an example of the JUnit xml format:
+@example
+@verbatim
+<?xml version="1.0" encoding="UTF-8"?>
+<testsuites tests="8" errors="1" failures="4">
+  <testsuite name="S1" tests="3" errors="1" failures="1">
+    <testcase classname="Core" name="test_pass">
+    </testcase>
+    <testcase classname="Core" name="test_fail">
+      <failure message="Failure">
+        Core:test_fail:0
+        ex_output.c:37
+        Failure
+      </failure>
+    </testcase>
+    <testcase classname="Core" name="test_exit">
+      <error message="Early exit with return value 1">
+        Core:test_exit:0
+        ex_output.c:46
+        Early exit with return value 1
+      </error>
+    </testcase>
+  </testsuite>
+  <testsuite name="S2" tests="4" errors="0" failures="2">
+    <testcase classname="Core" name="test_pass2">
+    </testcase>
+    <testcase classname="Core" name="test_loop">
+      <failure message="Iteration 0 failed">
+        Core:test_loop:0
+        ex_output.c:72
+        Iteration 0 failed
+      </failure>
+    </testcase>
+    <testcase classname="Core" name="test_loop">
+    </testcase>
+    <testcase classname="Core" name="test_loop">
+      <failure message="Iteration 2 failed">
+        Core:test_loop:2
+        ex_output.c:72
+        Iteration 2 failed
+      </failure>
+    </testcase>
+  </testsuite>
+</testsuites>
+@end verbatim
+@end example
+
+
 @node TAP Logging,  , Test Logging, Test Logging
 @subsection TAP Logging
 
diff --git a/doc/man/CMakeLists.txt b/doc/man/CMakeLists.txt
new file mode 100644
index 0000000..0275e64
--- /dev/null
+++ b/doc/man/CMakeLists.txt
@@ -0,0 +1,28 @@
+#
+# Check: a unit test framework for C
+# Copyright (C) 2020 Jose Fernando Lopez Fernandez
+# 
+# This library is free software; you can redistribute
+# it and/or modify it under the terms of the GNU Lesser
+# General Public License as published by the Free Software
+# Foundation; either version 2.1 of the License, or (at
+# your option) any later version.
+# 
+# This library is distributed in the hope that it will
+# be useful, but WITHOUT ANY WARRANTY; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.  See the GNU Lesser General Public
+# License for more details.
+# 
+# You should have received a copy of the GNU Lesser General
+# Public License along with this library; if not, write
+# to the Free Software Foundation, Inc., 51 Franklin St,
+# Fifth Floor, Boston, MA  02110-1301  USA
+#
+
+# Process each of the following man page directories once we
+# have successfully configured the necessary variable(s)
+# defined above.
+#
+ADD_SUBDIRECTORY(man3)
+ADD_SUBDIRECTORY(man7)
diff --git a/doc/man/Makefile.am b/doc/man/Makefile.am
new file mode 100644
index 0000000..583cbae
--- /dev/null
+++ b/doc/man/Makefile.am
@@ -0,0 +1 @@
+SUBDIRS = man3 man7
diff --git a/doc/man/man3/CMakeLists.txt b/doc/man/man3/CMakeLists.txt
new file mode 100644
index 0000000..f3f543d
--- /dev/null
+++ b/doc/man/man3/CMakeLists.txt
@@ -0,0 +1,82 @@
+#
+# Check: a unit test framework for C
+# Copyright (C) 2020 Jose Fernando Lopez Fernandez
+# 
+# This library is free software; you can redistribute
+# it and/or modify it under the terms of the GNU Lesser
+# General Public License as published by the Free Software
+# Foundation; either version 2.1 of the License, or (at
+# your option) any later version.
+# 
+# This library is distributed in the hope that it will
+# be useful, but WITHOUT ANY WARRANTY; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.  See the GNU Lesser General Public
+# License for more details.
+# 
+# You should have received a copy of the GNU Lesser General
+# Public License along with this library; if not, write
+# to the Free Software Foundation, Inc., 51 Franklin St,
+# Fifth Floor, Boston, MA  02110-1301  USA
+#
+
+# Define the library's section 3 man pages.
+#
+SET(MAN3_PAGES
+    suite_create.3
+)
+
+# Configure all of the section 3 man pages defined above.
+#
+# This command will process each of the man pages, setting
+# the project version and build date automatically.
+#
+FOREACH(MAN3_PAGE ${MAN3_PAGES})
+    # Configure the man pages.
+    #
+    # The configuration of each man page involves only the
+    # addition of the library version number defined in the
+    # configure.ac file to each man page.
+    #
+    CONFIGURE_FILE(${MAN3_PAGE}.in ${MAN3_PAGE} @ONLY)
+
+    # Install Section 3 Man Pages (Library Calls)
+    #
+    # This directive describes what, where, how, and when the
+    # section 3 man pages should be installed. Specifically, the
+    # ${CMAKE_INSTALL_MANDIR} variable provided by the
+    # GNUInstallDirs module specifies the system-specific man
+    # page installation directory, the permissions set the
+    # desired installed file(s) permissions, the configurations
+    # directive specifies that this directive applies for both
+    # Debug and Release configurations, and the component
+    # directive allows for the installation of only those items
+    # belonging to the docs component.
+    #
+    # For example, to install only the 'docs' component, the
+    # following command can be used after generating the project
+    # build files.
+    #
+    #   $ cmake --install . --component docs
+    #
+    # This example assumes the project build files were
+    # generated in the current working directory.
+    #
+    INSTALL(
+        FILES
+            ${CMAKE_CURRENT_BINARY_DIR}/${MAN3_PAGE}
+        DESTINATION
+            ${CMAKE_INSTALL_MANDIR}/man3
+        PERMISSIONS
+            OWNER_READ
+            OWNER_WRITE
+            GROUP_READ
+            WORLD_READ
+        CONFIGURATIONS
+            Debug
+            Release
+        COMPONENT
+            docs
+        OPTIONAL
+    )
+ENDFOREACH()
diff --git a/doc/man/man3/Makefile.am b/doc/man/man3/Makefile.am
new file mode 100644
index 0000000..5a5b05c
--- /dev/null
+++ b/doc/man/man3/Makefile.am
@@ -0,0 +1 @@
+dist_man_MANS = suite_create.3
diff --git a/doc/man/man3/suite_create.3.in b/doc/man/man3/suite_create.3.in
new file mode 100644
index 0000000..80c743b
--- /dev/null
+++ b/doc/man/man3/suite_create.3.in
@@ -0,0 +1,36 @@
+.\" Copyright (c) LibCheck, 2001-2020.
+.\" 
+.\" Permission is granted to copy, distribute and/or
+.\" modify this document under the terms of the GNU
+.\" Free Documentation License, Version 1.3 or any later
+.\" version published by the Free Software Foundation; with
+.\" no Invariant Sections, no Front-Cover Texts, and no
+.\" Back-Cover Texts.  A copy of the license is included in
+.\" the section entitled "GNU Free Documentation License".
+.\"
+.TH "suite_create" "3" "" "@PROJECT_VERSION@" "LibCheck"
+.SH "PROLOG"
+This manual page is part of the Check Programmer's Manual.
+Additional information may be found at the Check Library
+home page, at https://libcheck.github.io/check/.
+.SH "NAME"
+suite_create
+\(em create test case container object
+.SH "SYNOPSIS"
+.LP
+.nf
+#include <check.h>
+.P
+Suite* suite_create(const char *name);
+.SH "DESCRIPTION"
+The
+\fIsuite_create\fR()
+function returns a pointer to a heap-allocated test suite
+object.
+.SH "RETURN VALUE"
+Upon successful completion, the
+\fIsuite_create\fR()
+function returns a pointer containing the address of the
+heap-allocated test suite object. Otherwise, the function
+prints an error message to standard error indicating that
+something went wrong, and then returns a NULL pointer.
diff --git a/doc/man/man7/CMakeLists.txt b/doc/man/man7/CMakeLists.txt
new file mode 100644
index 0000000..0f5980d
--- /dev/null
+++ b/doc/man/man7/CMakeLists.txt
@@ -0,0 +1,82 @@
+#
+# Check: a unit test framework for C
+# Copyright (C) 2020 Jose Fernando Lopez Fernandez
+# 
+# This library is free software; you can redistribute
+# it and/or modify it under the terms of the GNU Lesser
+# General Public License as published by the Free Software
+# Foundation; either version 2.1 of the License, or (at
+# your option) any later version.
+# 
+# This library is distributed in the hope that it will
+# be useful, but WITHOUT ANY WARRANTY; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.  See the GNU Lesser General Public
+# License for more details.
+# 
+# You should have received a copy of the GNU Lesser General
+# Public License along with this library; if not, write
+# to the Free Software Foundation, Inc., 51 Franklin St,
+# Fifth Floor, Boston, MA  02110-1301  USA
+#
+
+# Define the library's section 7 man pages.
+#
+SET(MAN7_PAGES
+    libcheck.7
+)
+
+# Configure all of the section 7 man pages defined above.
+#
+# This command will process each of the man pages, setting
+# the project version and build date automatically.
+#
+FOREACH(MAN7_PAGE ${MAN7_PAGES})
+    # Configure the man pages.
+    #
+    # The configuration of each man page involves only the
+    # addition of the library version number defined in the
+    # configure.ac file to each man page.
+    #
+    CONFIGURE_FILE(${MAN7_PAGE}.in ${MAN7_PAGE} @ONLY)
+
+    # Install Section 7 Man Pages (Overview, Conventions, ...)
+    #
+    # This directive describes what, where, how, and when the
+    # section 7 man pages should be installed. Specifically, the
+    # ${CMAKE_INSTALL_MANDIR} variable provided by the
+    # GNUInstallDirs module specifies the system-specific man
+    # page installation directory, the permissions set the
+    # desired installed file(s) permissions, the configurations
+    # directive specifies that this directive applies for both
+    # Debug and Release configurations, and the component
+    # directive allows for the installation of only those items
+    # belonging to the docs component.
+    #
+    # For example, to install only the 'docs' component, the
+    # following command can be used after generating the project
+    # build files.
+    #
+    #   $ cmake --install . --component docs
+    #
+    # This example assumes the project build files were
+    # generated in the current working directory.
+    #
+    INSTALL(
+        FILES
+            ${CMAKE_CURRENT_BINARY_DIR}/${MAN7_PAGE}
+        DESTINATION
+            ${CMAKE_INSTALL_MANDIR}/man7
+        PERMISSIONS
+            OWNER_READ
+            OWNER_WRITE
+            GROUP_READ
+            WORLD_READ
+        CONFIGURATIONS
+            Debug
+            Release
+        COMPONENT
+            docs
+        OPTIONAL
+    )
+ENDFOREACH()
diff --git a/doc/man/man7/Makefile.am b/doc/man/man7/Makefile.am
new file mode 100644
index 0000000..58df7f3
--- /dev/null
+++ b/doc/man/man7/Makefile.am
@@ -0,0 +1 @@
+dist_man_MANS = libcheck.7
diff --git a/doc/man/man7/libcheck.7.in b/doc/man/man7/libcheck.7.in
new file mode 100644
index 0000000..b3c2e41
--- /dev/null
+++ b/doc/man/man7/libcheck.7.in
@@ -0,0 +1,26 @@
+.\" Copyright (c) LibCheck, 2001-2020.
+.\" 
+.\" Permission is granted to copy, distribute and/or
+.\" modify this document under the terms of the GNU
+.\" Free Documentation License, Version 1.3 or any later
+.\" version published by the Free Software Foundation; with
+.\" no Invariant Sections, no Front-Cover Texts, and no
+.\" Back-Cover Texts.  A copy of the license is included in
+.\" the section entitled "GNU Free Documentation License".
+.\"
+.TH "libcheck" "7" "" "@PROJECT_VERSION@" "LibCheck"
+.SH "PROLOG"
+This manual page is part of the Check Programmer's Manual.
+Additional information may be found at the Check Library
+home page, at https://libcheck.github.io/check/.
+.SH "NAME"
+libcheck
+\(em unit testing framework for C
+.SH "DESCRIPTION"
+Check is a unit testing framework for C. It features a
+simple interface for defining unit tests, putting little in
+the way of the developer. Tests are run in a separate
+address space, so Check can catch both assertion failures
+and code errors that cause segmentation faults or other
+signals. The output from unit tests can be used within
+source code editors and IDEs.
diff --git a/lib/libcompat.h b/lib/libcompat.h
index ea63a5e..b5983d7 100644
--- a/lib/libcompat.h
+++ b/lib/libcompat.h
@@ -89,6 +89,23 @@
 #include <process.h>            /* getpid */
 #endif /* _MSC_VER */
 
+/*
+ * On some not so old version of Visual Studio (< 2015), or with mingw-w64 not
+ * supporting POSIX printf family function, use the size prefix specifiers
+ * in msvcrt.dll. See the following link for the list of the size prefix
+ * specifiers:
+ * https://docs.microsoft.com/en-us/cpp/c-runtime-library/format-specification-syntax-printf-and-wprintf-functions?view=vs-2019
+ */
+#ifdef _WIN32
+#define CK_FMT_ZU "%Iu"
+#define CK_FMT_ZD "%Id"
+#define CK_FMT_TD "%Id"
+#else
+#define CK_FMT_ZU "%zu"
+#define CK_FMT_ZD "%zd"
+#define CK_FMT_TD "%td"
+#endif
+
 /* defines size_t */
 #include <sys/types.h>
 
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 4a02dbe..5787b59 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -110,7 +110,7 @@ endif(NOT HAVE_SNPRINTF)
 
 if(NOT HAVE_DECL_STRDUP AND NOT HAVE__STRDUP)
   target_sources(check PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../lib/strdup.c)
-  target_sources(checkShared PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../lib/snprintf.c)
+  target_sources(checkShared PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../lib/strdup.c)
 endif(NOT HAVE_DECL_STRDUP AND NOT HAVE__STRDUP)
 
 if(NOT HAVE_DECL_STRSIGNAL)
diff --git a/src/check.c b/src/check.c
index 89df345..da39ac3 100644
--- a/src/check.c
+++ b/src/check.c
@@ -156,6 +156,7 @@ TCase *tcase_create(const char *name)
     tc->unch_tflst = check_list_create();
     tc->ch_tflst = check_list_create();
     tc->tags = check_list_create();
+    tc->s = NULL;
 
     return tc;
 }
@@ -246,6 +247,7 @@ void suite_add_tcase(Suite * s, TCase * tc)
     {
         return;
     }
+    tc->s = s;
 
     check_list_add_end(s->tclst, tc);
 }
@@ -531,7 +533,7 @@ static void tr_init(TestResult * tr)
     tr->rtype = CK_TEST_RESULT_INVALID;
     tr->msg = NULL;
     tr->file = NULL;
-    tr->tcname = NULL;
+    tr->tc = NULL;
     tr->tname = NULL;
     tr->duration = -1;
 }
@@ -571,7 +573,7 @@ enum ck_result_ctx tr_ctx(TestResult * tr)
 
 const char *tr_tcname(TestResult * tr)
 {
-    return tr->tcname;
+    return tr->tc->name;
 }
 
 static enum fork_status _fstat = CK_FORK;
diff --git a/src/check.h.in b/src/check.h.in
index 6bee9d3..849ca2b 100644
--- a/src/check.h.in
+++ b/src/check.h.in
@@ -2261,6 +2261,48 @@ CK_DLL_EXP int CK_EXPORT srunner_has_tap(SRunner * sr);
  */
 CK_DLL_EXP const char *CK_EXPORT srunner_tap_fname(SRunner * sr);
 
+/**
+ * enum describing the specific XML format used for XML logging
+ */
+enum xml_format {
+    CK_XML_FORMAT_UNSPECIFIED,
+    CK_XML_FORMAT_DEFAULT,      // the default (original) format
+    CK_XML_FORMAT_JUNIT,        // output in JUnit compatible XML
+};
+
+/**
+ * Returns the XML format used if XML is to be logged.
+ *
+ * This value can be explicitly set via `srunner_set_xml_format` or can
+ * be set via the CK_XML_FORMAT_NAME environment variable.  
+ *
+ * @return CK_XML_FORMAT_DEFAULT unless the format is explicitly set via
+ *         `srunner_set_xml_format(sr, CK_XML_FORMAT_JUNIT)` or
+ *         `getenv("CK_XML_FORMAT_NAME")` returns "unit"
+ *
+ * @param sr suite runner to check
+ *
+ * @since 0.15.3.
+ */
+CK_DLL_EXP enum xml_format CK_EXPORT srunner_xml_format(SRunner * sr);
+
+/**
+ * Set the suite runner to output the result in an XML format compatible
+ * with JUnit's XML format.
+ *
+ * Note: XML format setting is an initialize only operation -- it should
+ * be done immediately after SRunner creation, and the XML format can't be
+ * changed after being set.
+ *
+ * This setting does not afffect the other log output types.
+ *
+ * @param sr suite runner to log results of in XML format
+ * @param format the xml_format to use
+ *
+ * @since 0.15.3
+*/
+CK_DLL_EXP void CK_EXPORT srunner_set_xml_format(SRunner * sr, enum xml_format format);
+
 /**
  * Enum describing the current fork usage.
  */
diff --git a/src/check_error.c b/src/check_error.c
index 02b40ae..56a7537 100644
--- a/src/check_error.c
+++ b/src/check_error.c
@@ -61,7 +61,7 @@ void *emalloc(size_t n)
 
     p = malloc(n);
     if(p == NULL)
-        eprintf("malloc of %zu bytes failed:", __FILE__, __LINE__ - 2, n);
+        eprintf("malloc of " CK_FMT_ZU " bytes failed:", __FILE__, __LINE__ - 2, n);
     return p;
 }
 
@@ -71,6 +71,6 @@ void *erealloc(void *ptr, size_t n)
 
     p = realloc(ptr, n);
     if(p == NULL)
-        eprintf("realloc of %zu bytes failed:", __FILE__, __LINE__ - 2, n);
+        eprintf("realloc of " CK_FMT_ZU " bytes failed:", __FILE__, __LINE__ - 2, n);
     return p;
 }
diff --git a/src/check_impl.h b/src/check_impl.h
index f4e8c59..f8ca35a 100644
--- a/src/check_impl.h
+++ b/src/check_impl.h
@@ -59,6 +59,7 @@ struct TCase
 {
     const char *name;
     struct timespec timeout;
+    struct Suite *s;
     List *tflst;                /* list of test functions */
     List *unch_sflst;
     List *unch_tflst;
@@ -82,7 +83,7 @@ struct TestResult
     int line;                   /* Line number where the test occurred */
     int iter;                   /* The iteration value for looping tests */
     int duration;               /* duration of this test in microseconds */
-    const char *tcname;         /* Test case that generated the result */
+    TCase *tc;                  /* Test case that generated the result */
     const char *tname;          /* Test that generated the result */
     char *msg;                  /* Failure message */
 };
@@ -121,6 +122,7 @@ struct SRunner
     List *resultlst;            /* List of unit test results */
     const char *log_fname;      /* name of log file */
     const char *xml_fname;      /* name of xml output file */
+    enum xml_format xml_format;
     const char *tap_fname;      /* name of tap output file */
     List *loglst;               /* list of Log objects */
     enum fork_status fstat;     /* controls if suites are forked or not
diff --git a/src/check_log.c b/src/check_log.c
index 0844661..9f6fb9e 100644
--- a/src/check_log.c
+++ b/src/check_log.c
@@ -22,6 +22,7 @@
 
 #include <stdlib.h>
 #include <stdio.h>
+#include <string.h>
 #include <check.h>
 #if ENABLE_SUBUNIT
 #include <subunit/child.h>
@@ -63,6 +64,27 @@ const char *srunner_log_fname(SRunner * sr)
     return getenv("CK_LOG_FILE_NAME");
 }
 
+enum xml_format srunner_xml_format(SRunner * sr)
+{
+    // if the format as been explicitly set already via
+    // `srunner_set_xml_format`, then use that value
+    if (sr->xml_format != CK_XML_FORMAT_UNSPECIFIED) 
+        return sr->xml_format;
+
+    // junit is the only value of CK_XML_FORMAT_NAME that will
+    // return something other than CK_XML_FORMAT_DEFAULT
+    const char *format_name = getenv("CK_XML_FORMAT_NAME");
+    if (format_name && strcmp(format_name, "junit") == 0)
+        return CK_XML_FORMAT_JUNIT;
+
+    return CK_XML_FORMAT_DEFAULT;
+}
+
+void srunner_set_xml_format(SRunner * sr, enum xml_format format)
+{
+    sr->xml_format = format;  
+}
+
 
 void srunner_set_xml(SRunner * sr, const char *fname)
 {
@@ -337,6 +359,65 @@ void xml_lfun(SRunner * sr CK_ATTRIBUTE_UNUSED, FILE * file,
 
 }
 
+void junit_lfun(SRunner * sr CK_ATTRIBUTE_UNUSED, FILE * file,
+              enum print_output printmode CK_ATTRIBUTE_UNUSED, void *obj,
+              enum cl_event evt)
+{
+    // we're only interested in the end of the full run.
+    if (evt != CLEND_SR) return;
+
+    TestResult *tr;
+    Suite *s;
+    TestStats stats;
+
+    fprintf(file, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
+    fprintf(file,
+            "<testsuites"
+            " tests=\"%d\""
+            " errors=\"%d\""
+            " failures=\"%d\""
+            ">\n",
+            sr->stats->n_checked, sr->stats->n_errors, sr->stats->n_failed);
+
+    // iterate over the suites
+    for (check_list_front(sr->slst); !check_list_at_end(sr->slst); check_list_advance(sr->slst)) {
+        s = (Suite*) check_list_val(sr->slst);
+
+        // calculate the stats
+        stats.n_checked = stats.n_errors = stats.n_failed = 0;
+        for (check_list_front(sr->resultlst); !check_list_at_end(sr->resultlst);
+             check_list_advance(sr->resultlst)) {
+            tr = (TestResult *)check_list_val(sr->resultlst);
+            if (tr->tc->s != s)
+                continue;
+            stats.n_checked++;
+            if (tr->rtype == CK_FAILURE)
+                stats.n_failed++;
+            else if (tr->rtype == CK_ERROR)
+                stats.n_errors++;
+        }
+
+        fprintf(file, "  <testsuite name=\"");
+        fprint_xml_esc(file, s->name);
+        fprintf(file,
+                "\""
+                " tests=\"%d\""
+                " errors=\"%d\""
+                " failures=\"%d\""
+                ">\n",
+                stats.n_checked, stats.n_errors, stats.n_failed);
+        for (check_list_front(sr->resultlst); !check_list_at_end(sr->resultlst);
+             check_list_advance(sr->resultlst)) {
+          tr = (TestResult *)check_list_val(sr->resultlst);
+          if (tr->tc->s != s)
+            continue;
+          tr_junitprint(file, tr, CK_VERBOSE);
+        }
+        fprintf(file, "  </testsuite>\n");
+    }
+    fprintf(file, "</testsuites>\n");
+}
+
 void tap_lfun(SRunner * sr CK_ATTRIBUTE_UNUSED, FILE * file,
               enum print_output printmode CK_ATTRIBUTE_UNUSED, void *obj,
               enum cl_event evt)
@@ -372,7 +453,7 @@ void tap_lfun(SRunner * sr CK_ATTRIBUTE_UNUSED, FILE * file,
             tr = (TestResult *)obj;
             fprintf(file, "%s %d - %s:%s:%s: %s\n",
                     tr->rtype == CK_PASS ? "ok" : "not ok", num_tests_run,
-                    tr->file, tr->tcname, tr->tname, tr->msg);
+                    tr->file, tr->tc->name, tr->tname, tr->msg);
             fflush(file);
             break;
         default:
@@ -520,7 +601,10 @@ void srunner_init_logging(SRunner * sr, enum print_output print_mode)
     f = srunner_open_xmlfile(sr);
     if(f)
     {
-        srunner_register_lfun(sr, f, f != stdout, xml_lfun, print_mode);
+        if (srunner_xml_format(sr) == CK_XML_FORMAT_JUNIT) 
+            srunner_register_lfun(sr, f, f != stdout, junit_lfun, print_mode);
+        else
+            srunner_register_lfun(sr, f, f != stdout, xml_lfun, print_mode);
     }
     f = srunner_open_tapfile(sr);
     if(f)
diff --git a/src/check_log.h b/src/check_log.h
index 7223b98..4b47c96 100644
--- a/src/check_log.h
+++ b/src/check_log.h
@@ -37,6 +37,9 @@ void lfile_lfun(SRunner * sr, FILE * file, enum print_output,
 void xml_lfun(SRunner * sr, FILE * file, enum print_output,
               void *obj, enum cl_event evt);
 
+void junit_lfun(SRunner * sr, FILE * file, enum print_output,
+              void *obj, enum cl_event evt);
+
 void tap_lfun(SRunner * sr, FILE * file, enum print_output,
               void *obj, enum cl_event evt);
 
diff --git a/src/check_pack.c b/src/check_pack.c
index 1d4f959..16893cf 100644
--- a/src/check_pack.c
+++ b/src/check_pack.c
@@ -136,7 +136,7 @@ int pack(enum ck_msg_type type, char **buf, CheckMsg * msg)
 
     len = pftab[type] (buf, msg);
     if(len > (size_t) INT_MAX)
-        eprintf("Value of len (%zu) too big, max allowed %u\n",
+        eprintf("Value of len (" CK_FMT_ZU ") too big, max allowed %u\n",
                 __FILE__, __LINE__ - 3, len, INT_MAX);
     return (int) len;
 }
@@ -159,10 +159,10 @@ int upack(char *buf, CheckMsg * msg, enum ck_msg_type *type)
 
     diff = buf - obuf;
     if(diff > (ptrdiff_t) INT_MAX)
-        eprintf("Value of diff (%td) too big, max allowed %d\n",
+        eprintf("Value of diff (" CK_FMT_TD ") too big, max allowed %d\n",
                 __FILE__, __LINE__ - 3, diff, INT_MAX);
     if(diff > (ptrdiff_t) INT_MAX || diff < (ptrdiff_t) INT_MIN)
-        eprintf("Value of diff (%td) too small, min allowed %d\n",
+        eprintf("Value of diff (" CK_FMT_TD ") too small, min allowed %d\n",
                 __FILE__, __LINE__ - 6, diff, INT_MIN);
     return (int) diff;
 }
@@ -203,7 +203,7 @@ static void pack_str(char **buf, const char *val)
     else
         strsz = strlen(val);
     if(strsz > CK_UINT32_MAX)
-        eprintf("Value of strsz (%zu) too big, max allowed %u\n",
+        eprintf("Value of strsz (" CK_FMT_ZU ") too big, max allowed %u\n",
                 __FILE__, __LINE__, strsz, CK_UINT32_MAX);
 
     pack_int(buf, (ck_uint32) strsz);
diff --git a/src/check_print.c b/src/check_print.c
index a9f3aea..559ded5 100644
--- a/src/check_print.c
+++ b/src/check_print.c
@@ -223,7 +223,7 @@ void tr_xmlprint(FILE * file, TestResult * tr,
             tr->duration < 0 ? -1 : tr->duration / US_PER_SEC,
             tr->duration < 0 ? 0 : tr->duration % US_PER_SEC);
     fprintf(file, "      <description>");
-    fprint_xml_esc(file, tr->tcname);
+    fprint_xml_esc(file, tr->tc->name);
     fprintf(file, "</description>\n");
     fprintf(file, "      <message>");
     fprint_xml_esc(file, tr->msg);
@@ -233,6 +233,77 @@ void tr_xmlprint(FILE * file, TestResult * tr,
     free(path_name);
 }
 
+void tr_junitprint(FILE * file, TestResult * tr,
+                 enum print_output print_mode CK_ATTRIBUTE_UNUSED)
+{
+    char status[10];
+    char type[10];
+    char *path_name = NULL;
+    char *file_name = NULL;
+    char *slash = NULL;
+    switch (tr->rtype)
+    {
+        case CK_PASS:
+            snprintf(status, sizeof(status), "%s", "success");
+            break;
+        case CK_FAILURE:
+            snprintf(status, sizeof(status), "%s", "failure");
+            break;
+        case CK_ERROR:
+            snprintf(status, sizeof(status), "%s", "error");
+            break;
+        case CK_TEST_RESULT_INVALID:
+        default:
+            abort();
+            break;
+    }
+
+    if(tr->file)
+    {
+        slash = strrchr(tr->file, '/');
+        if(slash == NULL)
+        {
+            slash = strrchr(tr->file, '\\');
+        }
+
+        if(slash == NULL)
+        {
+            path_name = strdup(".");
+            file_name = tr->file;
+        }
+        else
+        {
+            path_name = strdup(tr->file);
+            path_name[slash - tr->file] = 0;    /* Terminate the temporary string. */
+            file_name = slash + 1;
+        }
+    }
+
+    fprintf(file, "    <testcase"
+                  " classname=\"");
+    fprint_xml_esc(file, tr->tc->name);
+    fprintf(file,
+            "\""
+            " name=\"%s\""
+            ">\n",
+            tr->tname);
+
+    if (tr->rtype == CK_FAILURE || tr->rtype == CK_ERROR) {
+          fprintf(file, "      <%s message=\"", status);
+          fprint_xml_esc(file, tr->msg);
+          fprintf(file, "\">\n");
+          fprintf(file, "        ");
+          fprint_xml_esc(file, tr->tc->name);
+          fprintf(file, ":%s:%d\n", tr->tname, tr->iter);
+          fprintf(file, "        %s:%d\n", file_name, tr->line);
+          fprintf(file, "        ");
+          fprint_xml_esc(file, tr->msg);
+          fprintf(file, "\n");
+          fprintf(file, "      </%s>\n", status);
+    }
+    fprintf(file, "    </testcase>\n");
+}
+
 enum print_output get_env_printmode(void)
 {
     char *env = getenv("CK_VERBOSITY");
diff --git a/src/check_print.h b/src/check_print.h
index eabd8b9..bd06afe 100644
--- a/src/check_print.h
+++ b/src/check_print.h
@@ -25,6 +25,7 @@
 void fprint_xml_esc(FILE * file, const char *str);
 void tr_fprint(FILE * file, TestResult * tr, enum print_output print_mode);
 void tr_xmlprint(FILE * file, TestResult * tr, enum print_output print_mode);
+void tr_junitprint(FILE * file, TestResult * tr, enum print_output print_mode);
 void srunner_fprint(FILE * file, SRunner * sr, enum print_output print_mode);
 enum print_output get_env_printmode(void);
 
diff --git a/src/check_run.c b/src/check_run.c
index 5f160e5..1692fe7 100644
--- a/src/check_run.c
+++ b/src/check_run.c
@@ -70,7 +70,7 @@ static void srunner_iterate_suites(SRunner * sr,
 static void srunner_iterate_tcase_tfuns(SRunner * sr, TCase * tc);
 static void srunner_add_failure(SRunner * sr, TestResult * tf);
 static TestResult * srunner_run_setup(List * func_list,
-    enum fork_status fork_usage, const char * test_name,
+    enum fork_status fork_usage, struct TCase *tc,
     const char * setup_name);
 static int srunner_run_unchecked_setup(SRunner * sr, TCase * tc);
 static TestResult *tcase_run_checked_setup(SRunner * sr, TCase * tc);
@@ -80,7 +80,7 @@ static void tcase_run_checked_teardown(TCase * tc);
 static void srunner_run_tcase(SRunner * sr, TCase * tc);
 static TestResult *tcase_run_tfun_nofork(SRunner * sr, TCase * tc, TF * tf,
                                          int i);
-static TestResult *receive_result_info_nofork(const char *tcname,
+static TestResult *receive_result_info_nofork(struct TCase *tc,
                                               const char *tname, int iter,
                                               int duration);
 static void set_nofork_info(TestResult * tr);
@@ -89,7 +89,7 @@ static char *pass_msg(void);
 #if defined(HAVE_FORK) && HAVE_FORK==1
 static TestResult *tcase_run_tfun_fork(SRunner * sr, TCase * tc, TF * tf,
                                        int i);
-static TestResult *receive_result_info_fork(const char *tcname,
+static TestResult *receive_result_info_fork(struct TCase *tc,
                                             const char *tname, int iter,
                                             int status, int expected_signal,
                                             signed char allowed_exit_value);
@@ -288,7 +288,7 @@ static void srunner_add_failure(SRunner * sr, TestResult * tr)
 }
 
 static TestResult * srunner_run_setup(List * fixture_list, enum fork_status fork_usage,
-    const char * test_name, const char * setup_name)
+    struct TCase *tc, const char * setup_name)
 {
     TestResult *tr = NULL;
 
@@ -312,7 +312,7 @@ static TestResult * srunner_run_setup(List * fixture_list, enum fork_status fork
             }
 
             /* Stop the setup and return the failure in nofork mode. */
-            tr = receive_result_info_nofork(test_name, setup_name, 0, -1);
+            tr = receive_result_info_nofork(tc, setup_name, 0, -1);
             if(tr->rtype != CK_PASS)
             {
                 break;
@@ -338,7 +338,7 @@ static int srunner_run_unchecked_setup(SRunner * sr, TCase * tc)
     int rval = 1;
 
     set_fork_status(CK_NOFORK);
-    tr = srunner_run_setup(tc->unch_sflst, CK_NOFORK, tc->name, "unchecked_setup");
+    tr = srunner_run_setup(tc->unch_sflst, CK_NOFORK, tc, "unchecked_setup");
     set_fork_status(srunner_fork_status(sr));
 
     if(tr != NULL && tr->rtype != CK_PASS)
@@ -353,7 +353,7 @@ static int srunner_run_unchecked_setup(SRunner * sr, TCase * tc)
 static TestResult *tcase_run_checked_setup(SRunner * sr, TCase * tc)
 {
     TestResult *tr = srunner_run_setup(tc->ch_sflst, srunner_fork_status(sr),
-        tc->name, "checked_setup");
+        tc, "checked_setup");
 
     return tr;
 }
@@ -421,14 +421,14 @@ static TestResult *tcase_run_tfun_nofork(SRunner * sr, TCase * tc, TF * tfun,
         }
         clock_gettime(check_get_clockid(), &ts_end);
         tcase_run_checked_teardown(tc);
-        return receive_result_info_nofork(tc->name, tfun->ttest->name, i,
+        return receive_result_info_nofork(tc, tfun->ttest->name, i,
                                           DIFF_IN_USEC(ts_start, ts_end));
     }
 
     return tr;
 }
 
-static TestResult *receive_result_info_nofork(const char *tcname,
+static TestResult *receive_result_info_nofork(struct TCase *tc,
                                               const char *tname,
                                               int iter, int duration)
 {
@@ -441,7 +441,7 @@ static TestResult *receive_result_info_nofork(const char *tcname,
     }
     else
     {
-        tr->tcname = tcname;
+        tr->tc = tc;
         tr->tname = tname;
         tr->iter = iter;
         tr->duration = duration;
@@ -538,11 +538,11 @@ static TestResult *tcase_run_tfun_fork(SRunner * sr, TCase * tc, TF * tfun,
 
     killpg(pid, SIGKILL);       /* Kill remaining processes. */
 
-    return receive_result_info_fork(tc->name, tfun->ttest->name, i, status,
+    return receive_result_info_fork(tc, tfun->ttest->name, i, status,
                                     tfun->signal, tfun->allowed_exit_value);
 }
 
-static TestResult *receive_result_info_fork(const char *tcname,
+static TestResult *receive_result_info_fork(struct TCase* tc,
                                             const char *tname,
                                             int iter,
                                             int status, int expected_signal,
@@ -557,7 +557,7 @@ static TestResult *receive_result_info_fork(const char *tcname,
     }
     else
     {
-        tr->tcname = tcname;
+        tr->tc = tc;
         tr->tname = tname;
         tr->iter = iter;
         set_fork_info(tr, status, expected_signal, allowed_exit_value);
diff --git a/src/check_str.c b/src/check_str.c
index 8dabdcc..e998b0f 100644
--- a/src/check_str.c
+++ b/src/check_str.c
@@ -41,7 +41,7 @@ char *tr_str(TestResult * tr)
 
     rstr = ck_strdup_printf("%s:%d:%s:%s:%s:%d: %s%s",
                             tr->file, tr->line,
-                            tr_type_str(tr), tr->tcname, tr->tname, tr->iter,
+                            tr_type_str(tr), tr->tc->name, tr->tname, tr->iter,
                             exact_msg, tr->msg);
 
     return rstr;
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 5a925c2..ecb533b 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -93,3 +93,18 @@ target_link_libraries(check_nofork_teardown check)
 set(CHECK_SET_MAX_MSG_SIZE_SOURCES check_set_max_msg_size.c)
 add_executable(check_set_max_msg_size ${CHECK_SET_MAX_MSG_SIZE_SOURCES})
 target_link_libraries(check_set_max_msg_size check)
+
+set(CHECK_MEM_LEAKS_SOURCES
+  check_mem_leaks.c
+  check_check_log.c
+  check_check_limit.c
+  check_check_fixture.c
+  check_check_fork.c
+  check_check_exit.c
+  check_check_selective.c
+  check_check_sub.c
+  check_check_master.c
+  check_check_tags.c
+)
+add_executable(check_mem_leaks ${CHECK_MEM_LEAKS_SOURCES})
+target_link_libraries(check_mem_leaks check)
diff --git a/tests/check_check_log.c b/tests/check_check_log.c
index ee36fde..f6d2ff4 100644
--- a/tests/check_check_log.c
+++ b/tests/check_check_log.c
@@ -200,6 +200,55 @@ START_TEST(test_double_set_xml)
 }
 END_TEST
 
+START_TEST(test_default_xml_format) {
+  Suite *s = suite_create("Suite");
+  SRunner *sr = srunner_create(s);
+  ck_assert_msg(srunner_xml_format(sr) == CK_XML_FORMAT_DEFAULT,
+                "XML format is not default");
+  srunner_free(sr);
+}
+END_TEST
+
+START_TEST(test_set_xml_format) {
+  Suite *s = suite_create("Suite");
+  SRunner *sr = srunner_create(s);
+  srunner_set_xml_format(sr, CK_XML_FORMAT_JUNIT);
+  ck_assert_msg(srunner_xml_format(sr) == CK_XML_FORMAT_JUNIT,
+                "XML format is not Junit");
+  srunner_free(sr);
+}
+END_TEST
+
+#if HAVE_DECL_SETENV
+/* Test enabling JUnit XML format logging via environment variable */
+START_TEST(test_set_xml_format_env)
+{
+  const char *old_val;
+  Suite *s = suite_create("Suite");
+  SRunner *sr = srunner_create(s);
+
+  /* check that setting XML format via environment variable works */
+  ck_assert_msg(save_set_env("CK_XML_FORMAT_NAME", "junit", &old_val) == 0,
+              "Failed to set environment variable");
+
+  ck_assert_msg(srunner_xml_format(sr) == CK_XML_FORMAT_JUNIT,
+                "SRunner not set to use Junit");
+
+  /* check that explicit call to srunner_set_xml_format() overrides environment
+   * variable */
+  srunner_set_xml_format(sr, CK_XML_FORMAT_DEFAULT);
+  ck_assert_msg(srunner_xml_format(sr) == CK_XML_FORMAT_DEFAULT,
+                "SRunner not using explicitly set XML format");
+
+  /* restore old environment */
+  ck_assert_msg(restore_env("CK_XML_FORMAT_NAME", old_val) == 0,
+              "Failed to restore environment variable");
+  
+  srunner_free(sr);
+}
+END_TEST
+#endif /* HAVE_DECL_SETENV */
+
 START_TEST(test_set_tap)
 {
   Suite *s = suite_create("Suite");
@@ -302,6 +351,12 @@ Suite *make_log_suite(void)
   tcase_add_test(tc_core_xml, test_no_set_xml);
   tcase_add_test(tc_core_xml, test_double_set_xml);
 
+  tcase_add_test(tc_core_xml, test_default_xml_format);
+  tcase_add_test(tc_core_xml, test_set_xml_format);
+#if HAVE_DECL_SETENV
+  tcase_add_test(tc_core_xml, test_set_xml_format_env);
+#endif
+
   suite_add_tcase(s, tc_core_tap);
   tcase_add_test(tc_core_tap, test_set_tap);
 #if HAVE_DECL_SETENV
diff --git a/tests/check_check_master.c b/tests/check_check_master.c
index 781694a..2056e84 100644
--- a/tests/check_check_master.c
+++ b/tests/check_check_master.c
@@ -134,7 +134,7 @@ static master_test_t master_tests[] = {
   { "Simple Tests", "test_ck_assert_float_ge", CK_FAILURE, CK_MSG_TEXT, "Assertion 'x >= y' failed: x == 2.5, y == 3" },
   { "Simple Tests", "test_ck_assert_float_ge_with_mod", CK_FAILURE, CK_MSG_TEXT, "Assertion '2%d >= 3%f' failed: 2%d == 0, 3%f == 1" },
   { "Simple Tests", "test_ck_assert_float_with_expr", CK_PASS, CK_MSG_TEXT, "Passed" },
-  { "Simple Tests", "test_ck_assert_float_eq_tol", CK_FAILURE, CK_MSG_TEXT, "Assertion 'fabsl(y - x) < t' failed: x == 0.001, y == 0.003, t == 0.001" },
+  { "Simple Tests", "test_ck_assert_float_eq_tol", CK_FAILURE, CK_MSG_TEXT, "Assertion 'fabsl(y - x) < t' failed: x == 0.001, y == 0.003, t == 0.000990099" },
   { "Simple Tests", "test_ck_assert_float_eq_tol_with_mod", CK_FAILURE, CK_MSG_TEXT, "Assertion 'fabsl(2%f - 3%d) < 2%p' failed: 3%d == 1, 2%f == 0, 2%p == 0" },
   { "Simple Tests", "test_ck_assert_float_ne_tol", CK_FAILURE, CK_MSG_TEXT, "Assertion 'fabsl(y - x) >= t' failed: x == 0.001, y == 0.002, t == 0.01" },
   { "Simple Tests", "test_ck_assert_float_ne_tol_with_mod", CK_FAILURE, CK_MSG_TEXT, "Assertion 'fabsl(3%f - 3%d) >= 3%p' failed: 3%d == 1, 3%f == 1, 3%p == 1" },
@@ -174,7 +174,7 @@ static master_test_t master_tests[] = {
   { "Simple Tests", "test_ck_assert_double_ge", CK_FAILURE, CK_MSG_TEXT, "Assertion 'x >= y' failed: x == 2.5, y == 3" },
   { "Simple Tests", "test_ck_assert_double_ge_with_mod", CK_FAILURE, CK_MSG_TEXT, "Assertion '2%d >= 3%f' failed: 2%d == 0, 3%f == 1" },
   { "Simple Tests", "test_ck_assert_double_with_expr", CK_PASS, CK_MSG_TEXT, "Passed" },
-  { "Simple Tests", "test_ck_assert_double_eq_tol", CK_FAILURE, CK_MSG_TEXT, "Assertion 'fabsl(y - x) < t' failed: x == 0.001, y == 0.002, t == 0.001" },
+  { "Simple Tests", "test_ck_assert_double_eq_tol", CK_FAILURE, CK_MSG_TEXT, "Assertion 'fabsl(y - x) < t' failed: x == 0.001, y == 0.002, t == 0.000990099" },
   { "Simple Tests", "test_ck_assert_double_eq_tol_with_mod", CK_FAILURE, CK_MSG_TEXT, "Assertion 'fabsl(2%f - 3%d) < 2%p' failed: 3%d == 1, 2%f == 0, 2%p == 0" },
   { "Simple Tests", "test_ck_assert_double_ne_tol", CK_FAILURE, CK_MSG_TEXT, "Assertion 'fabsl(y - x) >= t' failed: x == 0.001, y == 0.002, t == 0.01" },
   { "Simple Tests", "test_ck_assert_double_ne_tol_with_mod", CK_FAILURE, CK_MSG_TEXT, "Assertion 'fabsl(3%f - 3%d) >= 3%p' failed: 3%d == 1, 3%f == 1, 3%p == 1" },
@@ -214,7 +214,7 @@ static master_test_t master_tests[] = {
   { "Simple Tests", "test_ck_assert_ldouble_ge", CK_FAILURE, CK_MSG_TEXT, "Assertion 'x >= y' failed: x == 2.5, y == 3" },
   { "Simple Tests", "test_ck_assert_ldouble_ge_with_mod", CK_FAILURE, CK_MSG_TEXT, "Assertion '2%d >= 3%f' failed: 2%d == 0, 3%f == 1" },
   { "Simple Tests", "test_ck_assert_ldouble_with_expr", CK_PASS, CK_MSG_TEXT, "Passed" },
-  { "Simple Tests", "test_ck_assert_ldouble_eq_tol", CK_FAILURE, CK_MSG_TEXT, "Assertion 'fabsl(y - x) < t' failed: x == 0.001, y == 0.002, t == 0.001" },
+  { "Simple Tests", "test_ck_assert_ldouble_eq_tol", CK_FAILURE, CK_MSG_TEXT, "Assertion 'fabsl(y - x) < t' failed: x == 0.001, y == 0.002, t == 0.000990099" },
   { "Simple Tests", "test_ck_assert_ldouble_eq_tol_with_mod", CK_FAILURE, CK_MSG_TEXT, "Assertion 'fabsl(2%f - 3%d) < 2%p' failed: 3%d == 1, 2%f == 0, 2%p == 0" },
   { "Simple Tests", "test_ck_assert_ldouble_ne_tol", CK_FAILURE, CK_MSG_TEXT, "Assertion 'fabsl(y - x) >= t' failed: x == 0.001, y == 0.002, t == 0.01" },
   { "Simple Tests", "test_ck_assert_ldouble_ne_tol_with_mod", CK_FAILURE, CK_MSG_TEXT, "Assertion 'fabsl(3%f - 3%d) >= 3%p' failed: 3%d == 1, 3%f == 1, 3%p == 1" },
@@ -908,7 +908,7 @@ void record_failure_line_num(int linenum)
   written = fwrite(string, 1, to_write, line_num_failures);
   if(written != to_write)
   {
-    fprintf(stderr, "%s:%d: Error in call to fwrite, wrote %zd instead of %zu:", __FILE__, __LINE__, written, to_write);
+    fprintf(stderr, "%s:%d: Error in call to fwrite, wrote " CK_FMT_ZD " instead of " CK_FMT_ZU ":", __FILE__, __LINE__, written, to_write);
     exit(1);
   }
 
diff --git a/tests/check_check_sub.c b/tests/check_check_sub.c
index 184a3bf..b581d5c 100644
--- a/tests/check_check_sub.c
+++ b/tests/check_check_sub.c
@@ -778,7 +778,7 @@ START_TEST(test_ck_assert_float_eq_tol)
   y*=10.0f;
   t*=10.0f;
   ck_assert_float_eq_tol(x, y, t);
-  t/=10.0f;
+  t/=10.1f;
   record_failure_line_num(__LINE__);
   ck_assert_float_eq_tol(x, y, t);
 }
@@ -1294,7 +1294,7 @@ START_TEST(test_ck_assert_double_eq_tol)
   y*=10;
   t*=10;
   ck_assert_double_eq_tol(x, y, t);
-  t/=10;
+  t/=10.1;
   record_failure_line_num(__LINE__);
   ck_assert_double_eq_tol(x, y, t);
 }
@@ -1812,7 +1812,7 @@ START_TEST(test_ck_assert_ldouble_eq_tol)
   y*=10.0l;
   t*=10.0l;
   ck_assert_ldouble_eq_tol(x, y, t);
-  t/=10.0l;
+  t/=10.1l;
   record_failure_line_num(__LINE__);
   ck_assert_ldouble_eq_tol(x, y, t);
 }
@@ -2677,7 +2677,7 @@ END_TEST
 
 /*
  * The following test will leak memory because it is calling
- * APIs inproperly. The leaked memory cannot be free'd, as
+ * APIs improperly. The leaked memory cannot be free'd, as
  * the methods to do so are static. (No user of Check should
  * call them directly).
  */
diff --git a/tests/ex_output.c b/tests/ex_output.c
index 89006cf..0ded1d0 100644
--- a/tests/ex_output.c
+++ b/tests/ex_output.c
@@ -136,7 +136,7 @@ static void print_usage(void)
     printf(" | CK_SUBUNIT");
 #endif
     printf(")\n");
-    printf("                 (STDOUT | STDOUT_DUMP | LOG | LOG_STDOUT | TAP | TAP_STDOUT | XML | XML_STDOUT)\n");
+    printf("                 (STDOUT | STDOUT_DUMP | LOG | LOG_STDOUT | TAP | TAP_STDOUT | XML | XML_STDOUT | JUNIT_XML | JUNIT_XML_STDOUT )\n");
     printf("                 (NORMAL | EXIT_TEST)\n");
     printf("   If CK_ENV is used, the environment variable CK_VERBOSITY can be set to\n");
     printf("   one of these: silent, minimal, or verbose. If it is not set to these, or\n");
@@ -190,6 +190,16 @@ static void run_tests(enum print_output printmode, char *log_type, int include_e
     {
         srunner_set_xml(sr, "-");
     }
+    else if(strcmp(log_type, "JUNIT_XML") == 0)
+    {
+        srunner_set_xml(sr, "junit_test.xml");
+        srunner_set_xml_format(sr, CK_XML_FORMAT_JUNIT);
+    }
+    else if(strcmp(log_type, "JUNIT_XML_STDOUT") == 0)
+    {
+        srunner_set_xml(sr, "-");
+        srunner_set_xml_format(sr, CK_XML_FORMAT_JUNIT);
+    }
     else
     {
         print_usage();
diff --git a/tests/test_junit_xml_output.sh b/tests/test_junit_xml_output.sh
new file mode 100755
index 0000000..eeed46f
--- /dev/null
+++ b/tests/test_junit_xml_output.sh
@@ -0,0 +1,31 @@
+#!/usr/bin/env sh
+
+OUTPUT_FILE=junit_test.xml
+CK_DEFAULT_TIMEOUT=4
+
+. ./test_vars
+. $(dirname $0)/test_output_strings
+
+rm -f ${OUTPUT_FILE}
+export CK_DEFAULT_TIMEOUT
+./ex_output${EXEEXT} CK_MINIMAL JUNIT_XML NORMAL > /dev/null
+actual_junit_xml=`cat ${OUTPUT_FILE} | tr -d "\r" | grep -v \<duration\> | grep -v \<datetime\> | grep -v \<path\>`
+if [ x"${expected_junit_xml}" != x"${actual_junit_xml}" ]; then
+    echo "Problem with ex_xml_output${EXEEXT}";
+    echo "Expected:";
+    echo "${expected_junit_xml}";
+    echo "Got:";
+    echo "${actual_junit_xml}";
+    exit 1;
+fi
+
+if [ ! -z `which xmllint` ]; then
+    xmllint_output=`xmllint ${OUTPUT_FILE}`
+    if [ $? -ne 0 ]; then
+        echo "xmllint found an issue"
+        echo ${xmllint_output}
+        exit 1
+    fi
+fi
+
+exit 0
diff --git a/tests/test_output.sh b/tests/test_output.sh
index c1b31bd..5935d2c 100755
--- a/tests/test_output.sh
+++ b/tests/test_output.sh
@@ -59,6 +59,8 @@ tap_stdout=`                             ./ex_output${EXEEXT} CK_SILENT TAP_STDO
 tap_env_stdout=`CK_TAP_LOG_FILE_NAME="-" ./ex_output${EXEEXT} CK_SILENT STDOUT NORMAL`
 xml_stdout=`                             ./ex_output${EXEEXT} CK_SILENT XML_STDOUT NORMAL  | tr -d "\r" | grep -v \<duration\> | grep -v \<datetime\> | grep -v \<path\>`
 xml_env_stdout=`CK_XML_LOG_FILE_NAME="-" ./ex_output${EXEEXT} CK_SILENT STDOUT NORMAL      | tr -d "\r" | grep -v \<duration\> | grep -v \<datetime\> | grep -v \<path\>`
+junit_xml_stdout=`                             ./ex_output${EXEEXT} CK_SILENT JUNIT_XML_STDOUT NORMAL  | tr -d "\r" | grep -v \<duration\> | grep -v \<datetime\> | grep -v \<path\>`
+junit_xml_env_stdout=`CK_XML_LOG_FILE_NAME="-" CK_XML_FORMAT_NAME="junit" ./ex_output${EXEEXT} CK_SILENT STDOUT NORMAL`
 
 test_output ( ) {
     if [ "x${1}" != "x${2}" ]; then
@@ -92,6 +94,8 @@ test_output "${expected_log_log}"    "${log_stdout}"     "CK_SILENT LOG_STDOUT N
 test_output "${expected_log_log}"    "${log_env_stdout}" "CK_SILENT STDOUT     NORMAL (with log env = '-')"
 test_output "${expected_xml}"        "${xml_stdout}"     "CK_SILENT XML_STDOUT NORMAL"
 test_output "${expected_xml}"        "${xml_env_stdout}" "CK_SILENT STDOUT     NORMAL (with xml env = '-')"
+test_output "${expected_junit_xml}"        "${junit_xml_stdout}"     "CK_SILENT JUNIT_XML_STDOUT NORMAL"
+test_output "${expected_junit_xml}"        "${junit_xml_env_stdout}" "CK_SILENT STDOUT     NORMAL (with junit_xml env = '-')"
 test_output "${expected_normal_tap}" "${tap_stdout}"     "CK_SILENT TAP_STDOUT NORMAL"
 test_output "${expected_normal_tap}" "${tap_env_stdout}" "CK_SILENT STDOUT     NORMAL (with tap env = '-')"
 
diff --git a/tests/test_output_strings b/tests/test_output_strings
index 21751b6..2c4022b 100644
--- a/tests/test_output_strings
+++ b/tests/test_output_strings
@@ -293,6 +293,60 @@ expected_xml="<?xml version=\"1.0\"?>
 expected_duration_count=8
 fi
 
+##################
+# junit xml output
+##################
+expected_junit_xml="<?xml version=\"1.0\" encoding=\"UTF-8\"?>
+<testsuites tests=\"8\" errors=\"1\" failures=\"4\">
+  <testsuite name=\"S1\" tests=\"3\" errors=\"1\" failures=\"1\">
+    <testcase classname=\"Core\" name=\"test_pass\">
+    </testcase>
+    <testcase classname=\"Core\" name=\"test_fail\">
+      <failure message=\"Failure\">
+        Core:test_fail:0
+        ex_output.c:37
+        Failure
+      </failure>
+    </testcase>
+    <testcase classname=\"Core\" name=\"test_exit\">
+      <error message=\"Early exit with return value 1\">
+        Core:test_exit:0
+        ex_output.c:46
+        Early exit with return value 1
+      </error>
+    </testcase>
+  </testsuite>
+  <testsuite name=\"S2\" tests=\"4\" errors=\"0\" failures=\"2\">
+    <testcase classname=\"Core\" name=\"test_pass2\">
+    </testcase>
+    <testcase classname=\"Core\" name=\"test_loop\">
+      <failure message=\"Iteration 0 failed\">
+        Core:test_loop:0
+        ex_output.c:72
+        Iteration 0 failed
+      </failure>
+    </testcase>
+    <testcase classname=\"Core\" name=\"test_loop\">
+    </testcase>
+    <testcase classname=\"Core\" name=\"test_loop\">
+      <failure message=\"Iteration 2 failed\">
+        Core:test_loop:2
+        ex_output.c:72
+        Iteration 2 failed
+      </failure>
+    </testcase>
+  </testsuite>
+  <testsuite name=\"XML escape &quot; &apos; &lt; &gt; &amp; &#x9; &#xA;X tests\" tests=\"1\" errors=\"0\" failures=\"1\">
+    <testcase classname=\"description &quot; &apos; &lt; &gt; &amp; &#x9; &#xA;X end\" name=\"test_xml_esc_fail_msg\">
+      <failure message=\"fail &quot; &apos; &lt; &gt; &amp; &#x9; &#xA;X message\">
+        description &quot; &apos; &lt; &gt; &amp; &#x9; &#xA;X end:test_xml_esc_fail_msg:0
+        ex_output.c:78
+        fail &quot; &apos; &lt; &gt; &amp; &#x9; &#xA;X message
+      </failure>
+    </testcase>
+  </testsuite>
+</testsuites>"
+
 ##################
 # tap output
 ##################
